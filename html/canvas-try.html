<body>
<div id="container"><canvas id="myDrawing" width="800" height="800">
<p>Your browser doesn't support canvas.</p>
</canvas>
    </div>
</body>
<style>
    #container {
        margin: 0 auto;
        width: 800px;
    }
    body {
        background: black;
</style>
<script>
var drawingCanvas = document.getElementById('myDrawing');
// Check the element is in the DOM and the browser supports canvas
    var plot = function (x,y,context) {
        var c = context;
        c.clearRect(0,0,800,800);
        for (var i = 0; i < x.length - 1; i++) {
            c.beginPath();
            c.moveTo(x[i],y[i]);
            c.lineTo(x[i+1],y[i+1]);
            c.closePath();
            c.stroke();
        }
    }
    var myMax = function (x) {
            return Math.max.apply(Math,x);
        },
        myMin = function (x) {
            return Math.min.apply(Math,x);
        };
    var linspace = function (start,end,n) {
        // return array with n regularly-space elements, starting with start and ending with end.
        var interval = (end - start) / (n - 1);
        var x = [];
        for (var i = 0; i < n; i++) {
            x.push(start + interval * i);
        };
        return x;
    };
    var scaleArray = function (x,s) {
        var newX = [];
        for (var i=0;i<x.length;i++) {
            newX.push(x[i]*s);
        };
        return newX;
    };
    var addToArray = function (x,a) {
        var newX = [];
        for (var i = 0; i < x.length; i++) {
            newX.push(x[i] + a);
        };
        return newX;
    };
    var centerAndScale = function (x,y,sideLength,percentage) {
        var innerSideLength = sideLength * percentage,
            offset = sideLength * (1-percentage) / 2,
            xRange = myMax(x) - myMin(x),
            yRange = myMax(y) - myMin(y),
            range = Math.max(xRange,yRange),
            scaleFactor = innerSideLength / range,
            scaledX = scaleArray(x,scaleFactor),
            scaledY = scaleArray(y,scaleFactor),
            newX = addToArray(scaledX,sideLength/2),
            newY = addToArray(scaledY,sideLength/2);
        return {x:newX,y:newY};
    };
    var generateGuilloche = function (options) {
        var getH = function (mean,amplitude,nCycles,nPoints) {
            var t = linspace(0,2*Math.PI,nPoints);
            var h = [];
            for (var i = 0; i < nPoints; i++) {
                var hi = amplitude * mean * Math.sin(nCycles * t[i]) + mean;
                h.push(hi);
            };
            return h;
        };
        var gx = function (t) {
            var x = [];
            for (var i = 0; i < t.length; i++) {
                var ti = t[i];
                var xi = (a-b)*Math.cos(m*ti)+h[i]*Math.cos(m*((a-b)/b)*ti);
                x.push(xi);
            }
            return x;
        };
        var gy = function (t) {
            var y = [];
            for (var i = 0; i < t.length; i++) {
                var ti = t[i];
                var yi = (a-b)*Math.sin(m*ti)-h[i]*Math.sin(m*((a-b)/b)*ti);
                y.push(yi);
            }
            return y;
        };
        
        var a = options.fixedRadius || 100,
            b = options.rollingRadius || 0.267,
            hr = options.tracingRadius || 120,
            hc = options.tracingRadiusCycles || 4003,
            ha = options.tracingRadiusAmplitude || 0.01,
            m = options.multiplier || 3,
            r = options.range || 2*Math.PI,
            n = options.nPoints || 9555.0,
            s = options.sideLength || 855,
            p = options.sidePercentage || 0.8;
        var t = linspace(0,r,n);    
        var h = getH(hr,ha,hc,n);
        var x = gx(t),
            y = gy(t);
        
//        var logScaleX = [];
//        var logScaleY = [];
//        
//        for (var i=0; i<x.length; i++) {
//            var r = Math.sqrt(Math.pow(x[i],2) + Math.pow(y[i],2));
//            var theta = Math.sin(y[i]/r)/Math.cos(x[i]/r);
//            var rNew = 0;
//            var rScaled = Math.log(r)/Math.log(10);
//            if (rScaled > 0) {
//                rNew = rScaled;
//            }
//            
//            logScaleXi = rNew*Math.sin(theta);
//            logScaleYi = rNew*Math.cos(theta);
//            
//            if (!logScaleXi) {
//                console.log(logScaleXi);
//                console.log([x[i],y[i],r,theta,rNew]);
//            }
//            logScaleX.push(logScaleXi);
//            logScaleY.push(logScaleYi);
//            
//        };
//        console.log(x);
//        console.log(logScaleX);
//        
//        x = logScaleX;
//        y = logScaleY;
        
        var scaledValues = centerAndScale(x,y,s,p);
        return {x:scaledValues.x,y:scaledValues.y};
    };
    if(drawingCanvas.getContext) {
        //initialize a 2-dimensional drawing context
        var c = drawingCanvas.getContext('2d');
        c.lineWidth = 1;
        c.strokeStyle = "rgba(255,255,255,0.05)";
        
        var param1 = "fixedRadius";
        var param1Vals = linspace(155.01,155.05,101);
        var param2 = "nPoints";
        var param2Vals = linspace(5206,5206,101);
        var param3 = "multiplier";
        var param3Vals = linspace(3.002,3.02,500);
//        [155.05053999999998, 5206.973947895792, 3.002
//        console.log(param1Vals[11]); 
        
//        155.04998, 5200.801603206412, 3.002] 
//        [155.05026, 5203.887775551102, 3.002] canvas-try.html:170

        i = 0;
        var fps = 20;
        var render = function (timestamp) {
            setTimeout(function () {
                var options = {};
                options[param1] = param1Vals[i];
                options[param2] = param2Vals[i];
                options[param3] = param3Vals[i];
                console.log([param1Vals[i],param2Vals[i],param3Vals[i]]);
                var guilloche = generateGuilloche(options);
                plot(guilloche.x,guilloche.y,c);
                i++;
                    requestAnimationFrame(render);
            }, 1000 / fps);
        };
        requestAnimationFrame(render);
    };

</script>